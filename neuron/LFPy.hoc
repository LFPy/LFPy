/* This file is no longer used, just kept here for future reference!!!!!!!!!!!!!*/

// Main .hoc-file for LFPy. H Linden 15.9.2008

// ------------------------------------------------------------------------
//create soma[1], dendrite[1], apical_dendrite[1], axon[1], iseg[1]//just so NEURON does not complain about nonexisting sections
// ------------------------------------------------------------------------

/*
NSTACK = 10000


create soma[1], axon[1], dend[1], apic[1]

soma {delete_section()}
axon {delete_section()}
dend {delete_section()}
apic {delete_section()} // Just so NEURON does not complain about nonexisting sections

objref axonlist, dendlist, apicdendlist, somalist, allseclist, alldendlist
*/

/*

proc load_geometry() {
	
	dendlistexist = 0
	apicdendlistexist = 0
	axonlistexist = 0
	sec_counted = 0
	
	load_file(1,$s1) //load geometry file	
	define_shape()
	create_sectionlists()

}
*/

/*
proc create_sectionlists() { // Loads geometry and creates sectionlists with sections of main parts of the neuron
	if (sec_counted == 0) {
		// Count number of sections of each type
		nsomasec = 0
		naxonsec = 0
		ndendsec = 0
		napicdendsec = 0
		
		forall {
			ifsec "soma*" {nsomasec += 1 }
			ifsec "axon*" {naxonsec += 1 }
			ifsec "dend*" {ndendsec += 1 }
			ifsec "apic*" {napicdendsec += 1 }
		}
	}
	
	//if (nsomasec > 0) {print "soma ", nsomasec}
	//if (naxonsec > 0) {print "axon ", naxonsec}
	//if (ndendsec > 0) {print "dend ", ndendsec}
	//if (napicdendsec > 0) {print "apicdend ", napicdendsec}
	
	// create SectionList for sections belonging to axon, dendrite and apical dendrite
	somalist = new SectionList()
	for (i=1; i<=nsomasec; i=i+1 ) {
		soma[i-1] somalist.append()
	}
	if (dendlistexist == 0) {
		dendlist = new SectionList()
		for (i=1; i<=ndendsec; i=i+1 ) {
			dend[i-1] dendlist.append()
		}
	}
	if (apicdendlistexist == 0) {
		apicdendlist = new SectionList()
		for (i=1; i<=napicdendsec; i=i+1 ) {
			apic[i-1] apicdendlist.append()
		}
	}
	if (axonlistexist == 0) {
		axonlist = new SectionList()
		for (i=1; i<=naxonsec; i=i+1 ) {
			axon[i-1] axonlist.append()	
		}
	}
	
	allseclist = new SectionList()
	forsec somalist allseclist.append()
	forsec dendlist allseclist.append()
	forsec apicdendlist allseclist.append()
 	forsec axonlist allseclist.append()

 	alldendlist = new SectionList()
 	forsec dendlist alldendlist.append()
 	forsec apicdendlist alldendlist.append()
}
*/

// ------------------------------------------------------------------------
/*
objref idxvec
proc get_idx() {//Takes sectionlist,totnsegs
	idxvec = new Vector($2)
	i = 0
	
	forsec allseclist {
		for (x,0) {
			ifsec $o1 {
				idxvec.x[i]=1 //Check sectionlist reference!
			}
			i += 1
		}	
	}
	
}
*/

// -----------------------------------------------------------------------------

/*
objref input_curr_vec_list, input_curr_vec, input_curr_tvec_list,input_curr_tvec
objref input_curr_syn, input_curr_syn_list
input_curr_vec_list = new List()
input_curr_tvec_list = new List()
input_curr_syn_list = new List()

func set_input_curr() { //Takes idx
	i = 0
	forsec allseclist {
		for (x,0) {
			if (i==$1) {

				input_curr_vec = new Vector()
				input_curr_tvec = new Vector()
				input_curr_vec_list.append(input_curr_vec)
				input_curr_tvec_list.append(input_curr_tvec)

				input_curr_syn = new IClampSyn(x)
				input_curr_syn.del = 0
				input_curr_syn.dur = 1e9
				input_curr_syn_list.append(input_curr_syn)

				input_curr_vec.play(&input_curr_syn.amp,input_curr_tvec)
				return input_curr_vec_list.count()-1
			}
		i += 1
		}
	}
}
*/

/*
// ------ PLAY IN SOMA --------------
objref soma_tvec, soma_trace

proc play_in_soma() {
    soma_tvec = new Vector()
    soma_trace = new Vector()
    
    soma_tvec = $o1
    soma_trace = $o2
    
    soma_trace.play(&soma.v(0.5), soma_tvec)
}
*/

/*
This should now be in model scripts, i.e my_active_declarations

// --------------------------------------------------------------
// Spines
// --------------------------------------------------------------
    // Based on the "Folding factor" described in
    // Jack et al (1989), Major et al (1994)
    // note, this assumes active channels are present in spines 
    // at same density as dendrites
spine_dens = 1
    // just using a simple spine density model due to lack of data on some 
    // neuron types.
spine_area = 0.83 // um^2  -- K Harris
proc add_spines() { local a
    is_spiny = 1
    if (strcmp($s1,"dend") == 0) {
        forsec dendlist {
            a = 0
            for (x,0) {
                a = a + area(x)
            }
            F = (L*spine_area*spine_dens + a)/a
            L = L * F^(2/3)
            for (x,0) {
                diam(x) = diam(x) * F^(1/3)
            }
            //original algorithm;
            //a = 0
            //for (x) print x
            //for(x) print diam(x)
            //for(x) a=a+area(x)
            //F = (L*spine_area*spine_dens + a)/a
            //L = L * F^(2/3)
            //for(x) diam(x) = diam(x) * F^(1/3)
            //for(x) print diam(x)
        }
    }
    define_shape()
}
*/